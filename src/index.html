<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
</body>
<script type="text/javascript">

function Queue() {
  const items = []

  this.enqueue = function(el) {
    items.push(el)
  }

  this.dequeue = function() {
    return items.shift()
  }
  this.front = function() {
    return items[0]
  }
  this.isEmpty = function() {
    return items.length === 0
  }
  this.size = function() {
    return items.length
  }
  this.print = function() {
    console.log(items)
  }
}

function Dictionary() {
  var items = {}

  this.has = function(key) {
    return key in items
  }

  this.set = function(key, value) {
    items[key] = value
  }

  this.remove = function(key) {
    if (this.has(key)) {
      delete items[key]
      return true
    }
    return false
  }

  this.get = function(key) {
    return this.has(key) ? items[key] : undefined
  }

  this.keys = function() {
    var keys = []
    for (i in items){
      if (this.has(i)) {
        keys.push(i)
      }
    }
    return keys
  }

  this.values = function() {
    var values = []
    for (var k in items) {
      if (this.has(k)) {
        values.push(items[k])
      }
    }
    return values
  }

  this.getItems = function() {
    return items
  }
}

function Graph() {
  var vertices = []
  var adjList = new Dictionary()

  this.addVertex = function(v) {
    vertices.push(v)
    adjList.set(v, [])
  }

  this.addEdge = function(v, w) {
    adjList.get(v).push(w)
    adjList.get(w).push(v)
  }

  this.toString = function() {
    var s = '\n'
    for (i of vertices) {
      s += `${i} -> `
      var neighbors = adjList.get(i)

      for (j of neighbors) {
        s += `${j} `
      }
      s += '\n'
    }
    return s
  }

  function initializeColor() {
    var color = []
    for (i of vertices) {
      color[i] = 'white'
    }
    return color
  }

  this.bfs = function(v) {
    var color = initializeColor(),
      queue = new Queue(),
      d = [],
      pred = []

    queue.enqueue(v)

    for (const i of vertices) {
      d[i] = 0
      pred[i] = null
    }

    while (!queue.isEmpty()) {
      var u = queue.dequeue()
      var neighbors = adjList.get(u)

      color[u] = 'grey'

      for (w of neighbors) {
        if (color[w] === 'white') {
          color[w] = 'grey'
          d[w] = d[u] + 1
          pred[w] = u
          queue.enqueue(w)
        }
      }

      color[u] = 'black'
    }

    return {
      distances: d,
      predecessors: pred
    }
  }
}

var graph = new Graph()

var myVertices = ['A','B','C','D','E','F','G','H','I']
for (i of myVertices){
  graph.addVertex(i)
}

graph.addEdge('A','B')
graph.addEdge('A','C')
graph.addEdge('A','D')

graph.addEdge('C','D')
graph.addEdge('C','G')
graph.addEdge('D','G')
graph.addEdge('D','H')

graph.addEdge('B','E')
graph.addEdge('B','F')
graph.addEdge('E','I')

function printNode(val){
  console.log(`visited vertex: ${val}`);
}

const path = graph.bfs(myVertices[0])
console.log(path);

var fromVertex = myVertices[0]

for (i of myVertices) {
  var toVertex = myVertices[i],
      p = new Stack()

  for (var v=toVertex; v!==fromVertex;v=path.predecessors[v]){
    p.push(v)
  }
  p.push(fromVertex)
  var s = p.pop()
  while (!p.isEmpty()){
    s += ` - ${p.pop()}`
  }
  console.log(s);
}


</script>
</html>